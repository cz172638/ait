#! /usr/bin/python
# -*- python -*-
# -*- coding: utf-8 -*-

import pygtk
pygtk.require("2.0")

import ethtool, gtk, gobject, os, procfs, re, schedutils, sys, utilist
import gtk.glade

# FIXME: should go to python-schedutils
( SCHED_OTHER, SCHED_FIFO, SCHED_RR, SCHED_BATCH ) = range(4)

#tuna_glade = "/usr/share/tuna/tuna_gui.glade"
tuna_glade = "./tuna_gui.glade"

class cpuview:

	( COL_FILTER, COL_CPU, COL_USAGE ) = range(3)

	def __init__(self, treeview):
		self.cpustats = procfs.cpusstats()
		self.treeview = treeview
		self.list_store = gtk.ListStore(gobject.TYPE_BOOLEAN,
						gobject.TYPE_UINT,
						gobject.TYPE_UINT)
		self.treeview.set_model(self.list_store)
		
		model = self.treeview.get_model()

		# Filter column
		renderer = gtk.CellRendererToggle()
		renderer.connect('toggled', self.filter_toggled, model)
		column = gtk.TreeViewColumn('Filter', renderer, active = self.COL_FILTER)
		self.treeview.append_column(column)

		# CPU# column
		column = gtk.TreeViewColumn('CPU', gtk.CellRendererText(),
					    text = self.COL_CPU)
		self.treeview.append_column(column)

		# CPU usage column
		column = gtk.TreeViewColumn('Usage', gtk.CellRendererProgress(),
					    text = self.COL_USAGE, value = self.COL_USAGE)
		self.treeview.append_column(column)

		self.timer = gobject.timeout_add(3000, self.refresh)

	def filter_toggled(self, cell, path, model):
		# get toggled iter
		iter = model.get_iter((int(path),))
		filtered = model.get_value(iter, self.COL_FILTER)

		# do something with the value
		filtered = not filtered

		# set new value
		model.set(iter, self.COL_FILTER, filtered)

	def refresh(self):
		self.list_store.clear()
		self.cpustats.reload()
		for cpunr in range(len(self.cpustats) - 1):
			cpu = self.list_store.append()
			usage = self.cpustats[cpunr + 1].usage
			self.list_store.set(cpu, self.COL_FILTER, True,
						 self.COL_CPU, cpunr,
						 self.COL_USAGE, int(usage))
		self.treeview.show_all()
		return True

def get_irq_users(irqs, irq, nics = None):
	if not nics:
		nics = ethtool.get_active_devices()
	users = irqs[irq]["users"]
	for u in users:
		if u in nics:
			users[users.index(u)] = "%s(%s)" % (u, ethtool.get_module(u))
	return users
			
def get_irq_affinity_text(irqs, irq):
	affinity_list = irqs[irq]["affinity"]
	try:
		if len(affinity_list) <= 4:
			return ("%s" % affinity_list)[1:-1].replace(" ", "")
		else:
			return utilist.csv(utilist.hexbitmask(affinity_list,
							      irqs.nr_cpus), '0x%x')
	except:
		# needs root prio to read /proc/irq/<NUM>/smp_affinity
		return ""

def on_affinity_text_changed(self):
	new_affinity_text = self.affinity.get_text()
	if self.affinity_text != new_affinity_text:
		try:
			for cpu in new_affinity_text.strip(",").split(","):
				new_affinity_cpu_entry = int(cpu, 16)
		except:
			if len(new_affinity_text.strip()) > 0:
				# print "not a hex number"
				self.affinity.set_text(self.affinity_text)
				return
		self.affinity_text = new_affinity_text

class irq_druid:

	def __init__(self, irqs, ps, irq):
		self.irqs = irqs
		self.ps = ps
		self.irq = irq
		self.window = gtk.glade.XML(tuna_glade, "set_irq_attributes")
		self.dialog = self.window.get_widget("set_irq_attributes")
		event_handlers = { "on_irq_affinity_text_changed" : self.on_irq_affinity_text_changed,
				   "on_sched_policy_combo_changed": self.on_sched_policy_combo_changed }
		self.window.signal_autoconnect(event_handlers)

		self.sched_pri = self.window.get_widget("irq_pri_spinbutton")
		self.sched_policy = self.window.get_widget("irq_policy_combobox")
		self.affinity = self.window.get_widget("irq_affinity_text")
		text = self.window.get_widget("irq_text")

		users = get_irq_users(irqs, irq)
		self.affinity_text = get_irq_affinity_text(irqs, irq)

		pids = ps.find_by_name("IRQ-%d" % irq)
		if pids:
			pid = pids[0]
			prio = int(ps[pid]["stat"]["rt_priority"])
			self.create_policy_model(self.sched_policy)
			self.sched_policy.set_active(schedutils.get_scheduler(pid))
			text.set_markup("IRQ <b>%u</b> (PID <b>%u</b>), pri <b>%u</b>, aff <b>%s</b>, <tt><b>%s</b></tt>" % \
					( irq, pid, prio, self.affinity_text,
					  utilist.csv(users, '%s')))
		else:
			self.sched_pri.set_sensitive(False)
			self.sched_policy.set_sensitive(False)
			text.set_markup("IRQ <b>%u</b>, aff <b>%s</b>, <tt><b>%s</b></tt>" % \
					( irq, self.affinity_text,
				 	  utilist.csv(users, '%s')))

		self.affinity.set_text(self.affinity_text)

	def create_policy_model(self, policy):
		( COL_TEXT, COL_SCHED ) = range(2)
		list_store = gtk.ListStore(gobject.TYPE_STRING,
					   gobject.TYPE_UINT)
		policy.set_model(list_store)
		renderer = gtk.CellRendererText()
		policy.pack_start(renderer, True)
		policy.add_attribute(renderer, "text", COL_TEXT)
		for pol in range(4):
			row = list_store.append()
			list_store.set(row, COL_TEXT, schedutils.schedstr(pol),
					    COL_SCHED, pol)

	def on_sched_policy_combo_changed(self, button):
		new_policy = self.sched_policy.get_active()
		if new_policy in ( SCHED_FIFO, SCHED_RR ):
			can_change_pri = True
		else:
			can_change_pri = False
		self.sched_pri.set_sensitive(can_change_pri)

	def on_irq_affinity_text_changed(self, button):
		on_affinity_text_changed(self)

	def run(self):
		rc = self.dialog.run()
		if rc == gtk.RESPONSE_OK:
			new_policy = self.sched_policy.get_active()
			new_prio = self.sched_pri.get_value()
			new_affinity = self.affinity.get_text()
			print "setting IRQ %d to policy=%s, prio=%d, affinity=%s" % \
			      (self.irq, schedutils.schedstr(new_policy),
			       new_prio, new_affinity)

		self.dialog.destroy()
		return rc

class irqview:

	( COL_NUM, COL_PID, COL_POL, COL_PRI, COL_AFF, COL_EVENTS, COL_NAME ) = range(7)
	labels = [ "IRQ", "PID", "Policy", "Priority", "Affinity",
		   "Events", "Name" ]

	def __init__(self, treeview, irqs):
		self.irqs = irqs
		self.treeview = treeview
		self.list_store = gtk.ListStore(gobject.TYPE_UINT,
				      		gobject.TYPE_INT,
				      		gobject.TYPE_STRING,
				      		gobject.TYPE_INT,
				      		gobject.TYPE_STRING,
				      		gobject.TYPE_UINT,
				      		gobject.TYPE_STRING)
		self.treeview.set_model(self.list_store)
		renderer = gtk.CellRendererText()

		for col in range(len(self.labels)):
			column = gtk.TreeViewColumn(self.labels[col], renderer, text = col)
			column.set_sort_column_id(col)
			self.treeview.append_column(column)

	def show(self, ps):
		self.ps = ps
		self.list_store.clear()

		irq_list = []
		for sirq in self.irqs.keys():
			try:
				irq_list.append(int(sirq))
			except:
				continue

		nics = ethtool.get_active_devices()

		irq_list.sort()
		for irqnr in irq_list:
			info = self.list_store.append()
			irq = self.irqs[irqnr]
			users = get_irq_users(self.irqs, irqnr, nics)

			pids = ps.find_by_name("IRQ-%d" % irqnr)
			if pids:
				pid = pids[0]
				prio = int(ps[pid]["stat"]["rt_priority"])
				sched = schedutils.schedstr(schedutils.get_scheduler(pid))[6:]
			else:
				sched = ""
				pid = -1
				prio = -1

			affinity_text = get_irq_affinity_text(self.irqs, irqnr)
			events = reduce(lambda a, b: a + b, irq["cpu"])

			self.list_store.set(info, self.COL_NUM, irqnr,
						  self.COL_PID, pid,
						  self.COL_POL, sched,
						  self.COL_PRI, prio,
						  self.COL_AFF, affinity_text,
						  self.COL_EVENTS, events,
						  self.COL_NAME, utilist.csv(users, '%s'))
		self.treeview.show_all()
	
	def refresh(self, ps):
		self.irqs.reload()
		self.show(self.ps)
		return True

	def edit_attributes(self, a):
		ret = self.treeview.get_path_at_pos(self.last_x, self.last_y)
		if not ret:
			return
		path, col, xpos, ypos = ret
		if not path:
			return
		row = self.list_store.get_iter(path)
		irq = self.list_store.get_value(row, self.COL_NUM)
		if not self.irqs.has_key(irq):
			return

		dialog = irq_druid(self.irqs, self.ps, irq)
		dialog.run()

	def on_irqlist_button_press_event(self, treeview, event):
		if event.type != gtk.gdk.BUTTON_PRESS or event.button != 3:
			return

		self.last_x = int(event.x)
		self.last_y = int(event.y)

		menu = gtk.Menu()

		setattr = gtk.MenuItem("_Set IRQ attributes")
		refresh = gtk.MenuItem("_Refresh IRQ list")

		menu.add(setattr)
		menu.add(refresh)

		setattr.connect_object('activate', self.edit_attributes, event)
		refresh.connect_object('activate', self.refresh, event)

		setattr.show()
		refresh.show()

		menu.popup(None, None, None, event.button, event.time)

class process_druid:

	( PROCESS_COL_PID, PROCESS_COL_NAME ) = range(2)

	def __init__(self, ps, pid, nr_cpus):
		self.ps = ps
		self.pid = pid
		self.nr_cpus = nr_cpus
		pid_info = self.ps[pid]
		self.window = gtk.glade.XML(tuna_glade, "set_process_attributes")
		self.dialog = self.window.get_widget("set_process_attributes")
		event_handlers = { "on_cmdline_regex_changed" : self.on_cmdline_regex_changed,
				   "on_affinity_text_changed" : self.on_affinity_text_changed,
				   "on_sched_policy_combo_changed" : self.on_sched_policy_combo_changed,
				   "on_command_regex_clicked" : self.on_command_regex_clicked,
				   "on_all_these_threads_clicked" : self.on_all_these_threads_clicked,
				   "on_just_this_thread_clicked" : self.on_just_this_thread_clicked }
		self.window.signal_autoconnect(event_handlers)

		self.sched_pri = self.window.get_widget("sched_pri_spin")
		self.sched_policy = self.window.get_widget("sched_policy_combo")
		self.regex_edit = self.window.get_widget("cmdline_regex")
		self.affinity = self.window.get_widget("affinity_text")
		self.just_this_thread = self.window.get_widget("just_this_thread")
		self.all_these_threads = self.window.get_widget("all_these_threads")
		processes = self.window.get_widget("matching_process_list")

		self.sched_pri.set_value(int(pid_info["stat"]["rt_priority"]))
		process_regex = pid_info["stat"]["comm"]
		affinity_list = schedutils.get_affinity(pid)
		if len(affinity_list) <= 4:
			self.affinity_text = ("%s" % affinity_list)[1:-1].replace(" ", "")
		else:
			self.affinity_text = utilist.csv(utilist.hexbitmask(affinity_list,
									    self.nr_cpus), '0x%x')
		self.affinity.set_text(self.affinity_text)
		self.create_matching_process_model(processes)
		self.create_policy_model(self.sched_policy)
		self.sched_policy.set_active(schedutils.get_scheduler(pid))
		self.regex_edit.set_text(process_regex)
		self.just_this_thread.set_active(True)
		self.regex_edit.set_sensitive(False)

	def refresh_match_pids(self, process_regex):
		self.process_list_store.clear()
		for match_pid in self.ps.find_by_regex(process_regex):
			info = self.process_list_store.append()
			self.process_list_store.set(info, self.PROCESS_COL_PID, match_pid,
						    self.PROCESS_COL_NAME, self.ps[match_pid]["stat"]["comm"])

	def create_matching_process_model(self, processes):
		labels = [ "PID", "Name" ]
		
		self.process_list_store = gtk.ListStore(gobject.TYPE_UINT,
							gobject.TYPE_STRING)
		processes.set_model(self.process_list_store)
		renderer = gtk.CellRendererText()

		for col in range(len(labels)):
			column = gtk.TreeViewColumn(labels[col], renderer, text = col)
			column.set_sort_column_id(col)
			processes.append_column(column)

	def create_policy_model(self, policy):
		( COL_TEXT, COL_SCHED ) = range(2)
		list_store = gtk.ListStore(gobject.TYPE_STRING,
					   gobject.TYPE_UINT)
		policy.set_model(list_store)
		renderer = gtk.CellRendererText()
		policy.pack_start(renderer, True)
		policy.add_attribute(renderer, "text", COL_TEXT)
		for pol in range(4):
			row = list_store.append()
			list_store.set(row, COL_TEXT, schedutils.schedstr(pol),
					    COL_SCHED, pol)

	def on_cmdline_regex_changed(self, entry):
		process_regex_text = entry.get_text()
		process_regex = re.compile(process_regex_text)
		self.refresh_match_pids(process_regex)

	def on_just_this_thread_clicked(self, button):
		self.regex_edit.set_sensitive(False)

	def on_command_regex_clicked(self, button):
		self.regex_edit.set_sensitive(True)

	def on_all_these_threads_clicked(self, button):
		self.regex_edit.set_sensitive(False)

	def on_sched_policy_combo_changed(self, button):
		new_policy = self.sched_policy.get_active()
		if new_policy in ( SCHED_FIFO, SCHED_RR ):
			can_change_pri = True
		else:
			can_change_pri = False
		self.sched_pri.set_sensitive(can_change_pri)

	def on_affinity_text_changed(self, button):
		on_affinity_text_changed(self)


	def invalid_affinity(self):
		dialog = gtk.MessageDialog(None,
					   gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
					   gtk.MESSAGE_WARNING,
					   gtk.BUTTONS_OK,
					   "Invalid affinity, specify a list of CPUs!")
		dialog.run()
		dialog.destroy()
		return False

	def set_attributes(self, pid, new_policy, new_prio, new_affinity):
		changed = False
		curr_policy = schedutils.get_scheduler(pid)
		curr_prio = int(self.ps[pid]["stat"]["rt_priority"])
		if curr_policy != new_policy or curr_prio != new_prio:
			try:
				schedutils.set_scheduler(pid, new_policy, new_prio)
			except:
				dialog = gtk.MessageDialog(None,
							   gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
							   gtk.MESSAGE_WARNING,
							   gtk.BUTTONS_OK,
							   "Invalid parameters!")
				dialog.run()
				dialog.destroy()
				return False

			curr_policy = schedutils.get_scheduler(pid)
			if curr_policy != new_policy:
				print "couldn't change pid %d from %s(%d) to %s(%d)!" % \
				      ( pid, schedutils.schedstr(curr_policy),
					curr_prio,
					schedutils.schedstr(new_policy),
					new_prio)
			else:
				changed = True

		curr_affinity = schedutils.get_affinity(pid)
		try:
			new_affinity = [ int(a) for a in new_affinity.split(",") ]
		except:
			new_affinity = utilist.bitmasklist(new_affinity, self.nr_cpus)
			
		new_affinity.sort()

		if curr_affinity != new_affinity:
			try:
				schedutils.set_affinity(pid, new_affinity)
			except:
				return self.invalid_affinity()

			curr_affinity = schedutils.get_affinity(pid)
			if curr_affinity != new_affinity:
				print "couldn't change pid %d from %s to %s!" % \
				      ( pid, curr_affinity, new_affinity )
			else:
				changed = True

		return changed

	def run(self):
		changed = False
		if self.dialog.run() == gtk.RESPONSE_OK:
			new_policy = int(self.sched_policy.get_active())
			new_prio = int(self.sched_pri.get_value())
			new_affinity = self.affinity.get_text()
			if self.just_this_thread.get_active():
				changed = self.set_attributes(self.pid, new_policy,
							      new_prio, new_affinity)
			elif self.all_these_threads.get_active():
				print "setting all threads of pid %d to policy=%s, prio=%d, affinity=%s" % \
				      (self.pid, schedutils.schedstr(new_policy),
				       new_prio, new_affinity)
			else:
				print "setting all threads that match regex '%s' to policy=%s, prio=%d, affinity=%s" % \
				      (self.regex_edit.get_text(),
				       schedutils.schedstr(new_policy),
				       new_prio, new_affinity)

		self.dialog.destroy()
		return changed

class procview:

	( COL_PID, COL_POL, COL_PRI, COL_AFF, COL_VOLCTXT, COL_NONVOLCTXT, COL_NAME ) = range(7)
	labels = [ "PID", "Policy", "Priority", "Affinity",
		   "VolCtxtSwitch", "NonVolCtxtSwitch", "Name" ]

	def __init__(self, treeview):
		self.treeview = treeview
		self.nr_cpus = procfs.cpuinfo().nr_cpus
		self.list_store = gtk.ListStore(gobject.TYPE_UINT,
				      		gobject.TYPE_STRING,
				      		gobject.TYPE_INT,
				      		gobject.TYPE_STRING,
				      		gobject.TYPE_INT,
				      		gobject.TYPE_INT,
				      		gobject.TYPE_STRING)
		self.treeview.set_model(self.list_store)
		renderer = gtk.CellRendererText()

		for col in range(len(self.labels)):
			column = gtk.TreeViewColumn(self.labels[col], renderer, text = col)
			column.set_sort_column_id(col)
			self.treeview.append_column(column)

	def show(self, ps):
		self.ps = ps
		self.list_store.clear()

		pid_list = ps.keys()
		pid_list.sort()

		for pid in pid_list:
			info = self.list_store.append()

			try:
				sched = schedutils.schedstr(schedutils.get_scheduler(pid))[6:]
			except SystemError:
				# Process doesn't exists anymore
				self.list_store.remove(info)
				continue

			prio = int(ps[pid]["stat"]["rt_priority"])

			thread_affinity_list = schedutils.get_affinity(pid)
			if len(thread_affinity_list) <= 4:
				thread_affinity = ("%s" % thread_affinity_list)[1:-1].replace(" ", "")
			else:
				thread_affinity = utilist.csv(utilist.hexbitmask(thread_affinity_list,
										 self.nr_cpus), '0x%x')
			try:
				voluntary_ctxt_switches = int(ps[pid]["status"]["voluntary_ctxt_switches"])
				nonvoluntary_ctxt_switches = int(ps[pid]["status"]["nonvoluntary_ctxt_switches"])
			except:
				voluntary_ctxt_switches = -1
				nonvoluntary_ctxt_switches = -1

			self.list_store.set(info, self.COL_PID, pid,
						  self.COL_POL, sched,
						  self.COL_PRI, prio,
						  self.COL_AFF, thread_affinity,
						  self.COL_VOLCTXT, voluntary_ctxt_switches,
						  self.COL_NONVOLCTXT, nonvoluntary_ctxt_switches,
						  self.COL_NAME, ps[pid]["stat"]["comm"])
		self.treeview.show_all()
		return True

	def refresh(self, a = None):
		self.ps.reload()
		self.show(self.ps)
		return True

	def edit_attributes(self, a):
		ret = self.treeview.get_path_at_pos(self.last_x, self.last_y)
		if not ret:
			return
		path, col, xpos, ypos = ret
		if not path:
			return
		row = self.list_store.get_iter(path)
		pid = self.list_store.get_value(row, self.COL_PID)
		if not self.ps.has_key(pid):
			return

		dialog = process_druid(self.ps, pid, self.nr_cpus)
		if dialog.run():
			self.refresh()

	def on_processlist_button_press_event(self, treeview, event):
		if event.type != gtk.gdk.BUTTON_PRESS or event.button != 3:
			return

		self.last_x = int(event.x)
		self.last_y = int(event.y)

		menu = gtk.Menu()

		setattr = gtk.MenuItem("_Set process attributes")
		refresh = gtk.MenuItem("_Refresh process list")

		menu.add(setattr)
		menu.add(refresh)

		setattr.connect_object('activate', self.edit_attributes, event)
		refresh.connect_object('activate', self.refresh, event)

		setattr.show()
		refresh.show()

		menu.popup(None, None, None, event.button, event.time)

class tuna:

	def __init__(self):
		if self.check_root():
			sys.exit(1)
		self.ps = procfs.pidstats()
		self.irqs = procfs.interrupts()
		self.wtree = gtk.glade.XML(tuna_glade, "mainbig_window")

		self.cpuview = cpuview(self.wtree.get_widget("cpuview"))
		self.irqview = irqview(self.wtree.get_widget("irqlist"), self.irqs)
		self.procview = procview(self.wtree.get_widget("processlist"))

		event_handlers = { "on_mainbig_window_delete_event"    : self.on_mainbig_window_delete_event,
				   "on_processlist_button_press_event" : self.procview.on_processlist_button_press_event,
				   "on_irqlist_button_press_event"     : self.irqview.on_irqlist_button_press_event }
		self.wtree.signal_autoconnect(event_handlers)

		self.show()
		# self.timer = gobject.timeout_add(5000, self.refresh)

	def on_mainbig_window_delete_event(self, obj, event):
		gtk.main_quit()

	def show(self):
		self.cpuview.refresh()
		self.irqview.show(self.ps)
		self.procview.show(self.ps)

	def refresh(self):
		self.ps.reload()
		self.irqview.refresh(self.ps)
		self.procview.show(self.ps)
		return True

	def check_root(self):
		if os.getuid() == 0:
			return False

		dialog = gtk.MessageDialog(None,
					   gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
					   gtk.MESSAGE_WARNING,
					   gtk.BUTTONS_YES_NO,
					   "Root priviledge required\n\n" + \
					   "Some functions will not work without root " + \
					   "privilege.\nDo you want to continue?")
		ret = dialog.run()
		dialog.destroy()
		if ret == gtk.RESPONSE_NO:
			return True
		return False

def main():
	try:
		tuna()
		gtk.main()
	except KeyboardInterrupt:
		pass

if __name__ == '__main__':
    main()
